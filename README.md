# Chapter 2-1. 클린코드와 리팩토링

## 기본과제: 더티코드 개선

이번 과제는 더티코드를 클린코드의 형태로 개선을 하는 과제입니다. 주어진 테스트를 통과하면서 원래 기능과 동일한 동작을 하는 코드를 만들어주세요. basic과제는 제공되는 더티코드를 클린코드와 리팩토링 원칙에 입각해서 더 나은 코드로 만들어보세요. 주어진 테스트를 참고삼아 좋은 이름, 좋은 모양, 좋은 구조를 가지는 코드로 만들어 보세요.

[필수조건]

- Prettier와 ESLint를 설치해서 적용할 것
- 테스트 코드 모두 통과할 것
- = 기존 기능과 동일하게 동작할 것
- = 어플리케이션 요구사항을 모두 만족할 것
  - 상품
    - 상품1 - 10,000원
    - 상품2 - 20,000원
    - 상품3 - 30,000원
  - 상품 관리
    - 상품을 장바구니에 추가할 수 있어야 한다.
    - 장바구니에서 상품을 제거할 수 있어야 한다.
    - 각 상품의 수량을 변경할 수 있어야 한다.
    - 재고가 부족한 상품은 장바구니에 담을 수 없습니다.
  - 가격 계산
    - 장바구니 내 모든 상품의 총액을 계산해야 한다.
    - 개별 상품의 가격과 수량에 따른 소계를 표시해야 한다.
    - 상품1 > 10개 이상 구매 시 10% 할인
    - 상품2 > 10개 이상 구매 시 15% 할인
    - 상품3 > 10개 이상 구매 시 20% 할인
    - 상품 종류와 상관 없이, 30개 이상 구매할 경우 25% 할인
    - 화요일에는 특별할인 10%
    - 임의의 시간마다 깜짝세일 20%, 추천세일 5%
  - 기본 기능
    - 장바구니에 상품 추가 기능
    - 장바구니에서 상품 제거 기능
    - 상품 수량 변경 기능
    - 장바구니 내역 조회 기능
    - 총액 계산 기능

## 심화과제: 유지보수 하기 좋은 코드만들기

심화과제는 **기본과제에서 작성한 코드를 기술고도화를 하는 것입니다.** 바닐라 자바스크립트로 되어 있는 코드를 유지보수하기에 유리한 기술스택(React + Typescript)으로 고도화 리팩토링을 진행해주세요.
우리의 목표는 앞으로 유지보수를 더 잘할 수 있도록 하기 위함입니다. 최소 React와 Typescript를 이용한 코드로 개선해주세요. 그 밖의 기술선택과 폴더/파일 구조, 테스트 코드등은 자유입니다.

## 과제 체크포인트

### 기본과제

- [x] 코드가 Prettier를 통해 일관된 포맷팅이 적용되어 있는가?
- [x] 적절한 줄바꿈과 주석을 사용하여 코드의 논리적 단위를 명확히 구분했는가?
- [x] 변수명과 함수명이 그 역할을 명확히 나타내며, 일관된 네이밍 규칙을 따르는가?
- [x] 매직 넘버와 문자열을 의미 있는 상수로 추출했는가?
- [x] 중복 코드를 제거하고 재사용 가능한 형태로 리팩토링했는가?
- [x] 함수가 단일 책임 원칙을 따르며, 한 가지 작업만 수행하는가?
- [x] 조건문과 반복문이 간결하고 명확한가? 복잡한 조건을 함수로 추출했는가?
- [x] 코드의 배치가 의존성과 실행 흐름에 따라 논리적으로 구성되어 있는가?
- [x] 연관된 코드를 의미 있는 함수나 모듈로 그룹화했는가?
- [x] ES6+ 문법을 활용하여 코드를 더 간결하고 명확하게 작성했는가?
- [x] 전역 상태와 부수 효과(side effects)를 최소화했는가?
- [ ] 에러 처리와 예외 상황을 명확히 고려하고 처리했는가?
- [ ] 코드 자체가 자기 문서화되어 있어, 주석 없이도 의도를 파악할 수 있는가?
- [x] 비즈니스 로직과 UI 로직이 적절히 분리되어 있는가?
- [x] 코드의 각 부분이 테스트 가능하도록 구조화되어 있는가?
- [x] 성능 개선을 위해 불필요한 연산이나 렌더링을 제거했는가?
- [x] 새로운 기능 추가나 변경이 기존 코드에 미치는 영향을 최소화했는가?
- [x] 리팩토링 시 기존 기능을 그대로 유지하면서 점진적으로 개선했는가?
- [ ] 코드 리뷰를 통해 다른 개발자들의 피드백을 반영하고 개선했는가?

### 심화과제

- [x] 변경한 구조와 코드가 기존의 코드보다 가독성이 높고 이해하기 쉬운가?
- [x] 변경한 구조와 코드가 기존의 코드보다 기능을 수정하거나 확장하기에 용이한가?
- [x] 변경한 구조와 코드가 기존의 코드보다 테스트를 하기에 더 용이한가?
- [x] 변경한 구조와 코드가 기존의 모든 기능은 그대로 유지했는가?
- [ ] 변경한 구조와 코드를 새로운 한번에 새로만들지 않고 점진적으로 개선했는가?


## 과제 셀프회고


항목 |  
-- | --
함수명, 변수명, 인자명 | 1. 함수명은 함수의 역할이 드러나도록 상세하게 작성한다.  <br>   ~~- 의미를 전달하며, 줄여쓸 수 있다면 축약한다. (예: calculate -> cal)~~   <br> 2. 함수명은 동사로 시작한다. <br> 3. 인수로 표현할 수 있는 값은 함수명에서 생략한다.  <br>   - 예: A에서 B로 길을 찾는 함수 -> findPath(A, B)  <br> 4. 데이터 → 복수, UI → list  <br>     -예: 데이터: products / UI: ProdutList <br> 5. 컴포넌트는 파스칼, 일반은 카멜케이스로 표현한다. (케밥케이스 X)
타입 컨벤션인터페이스명, 함수 시그니쳐, 넓은 타입처리 | 1. 중복을 줄이기 위해 구체적으로 작성한다.  <br> ~~2. 2 Depth까지 표현한다 (예: UserDetail).~~ <br> 3. 유틸리티 타입을 활용한다. (예: Pick, Omit)  <br> 4. 데이터 타입 → 단수, UI 타입→ list  <br>    -예: 데이터: product / UI: ProdutListProps
함수 선언 컨벤션 | 1. 기본 규칙은 함수 표현식을 사용한다. (유틸 함수 포함)  <br>   - 단, 컴포넌트는 함수 선언문(function)을 사용한다.  <br>    - 표현식에서는 기본적으로 화살표 함수를 사용한다. <br> 2. 내보내기 시 기본 규칙은 export로 한다. <br> ~~단, 컴포넌트는 export default를 사용한다.~~ <br> 3. 인수 객체 형태로 사용한다. (인수 객체에 대한 근거는 아래 참고)
파일 디렉토리 규칙 |  1. 배럴 파일을 사용한다. <br> 2. FSD 아키텍처를 사용한다.


1. FSD 아키텍처 적용 ( 과제 중간 리뷰 때 프로젝트 규모와 적합하지 않다고했지만 이미 진행된 사항이 많아서 적용 )

- app
  - 앱을 실행하는 모든 것 
  - 라우팅, 진입점, 전역 스타일, 프로바이더
- pages
  - 전체 페이지 또는 중첩 라우팅에서 페이지의 주요 부분.
- widgets
  - 독립적으로 작동하는 대규모 기능 또는 UI 컴포넌트, 보통 하나의 완전한 기능.
- features
  -  제품 전반에 걸쳐 재사용되는 기능 구현체로, 사용자에게 실질적인 비즈니스 가치를 제공하는 동작.
- entities
  - 프로젝트가 다루는 비즈니스 엔티티
- shared
  -  재사용 가능한 기능, 특히 프로젝트/비즈니스의 특성과 분리되어 있을 때

```
advanced
 ┣ __tests__
 ┃ ┗ advanced.test.tsx
 ┣ app
 ┃ ┗ index.tsx
 ┣ entities
 ┃ ┗ product
 ┃ ┃ ┣ api
 ┃ ┃ ┃ ┣ getProducts.ts
 ┃ ┃ ┃ ┗ index.ts
 ┃ ┃ ┣ model
 ┃ ┃ ┃ ┣ index.ts
 ┃ ┃ ┃ ┗ types.ts
 ┃ ┃ ┗ index.ts
 ┣ features
 ┃ ┣ cart
 ┃ ┃ ┣ config
 ┃ ┃ ┃ ┗ index.ts
 ┃ ┃ ┣ lib
 ┃ ┃ ┃ ┗ index.ts
 ┃ ┃ ┣ model
 ┃ ┃ ┃ ┣ index.ts
 ┃ ┃ ┃ ┣ types.ts
 ┃ ┃ ┃ ┗ useCart.ts
 ┃ ┃ ┣ ui
 ┃ ┃ ┃ ┣ CartDisplay.tsx
 ┃ ┃ ┃ ┣ CartItem.tsx
 ┃ ┃ ┃ ┣ CartTotal.tsx
 ┃ ┃ ┃ ┗ index.ts
 ┃ ┃ ┗ index.ts
 ┃ ┗ stock
 ┃ ┃ ┣ model
 ┃ ┃ ┃ ┣ index.ts
 ┃ ┃ ┃ ┗ useStock.ts
 ┃ ┃ ┣ ui
 ┃ ┃ ┃ ┣ StockStatus.tsx
 ┃ ┃ ┃ ┗ index.ts
 ┃ ┃ ┗ index.ts
 ┣ pages
 ┃ ┗ cart
 ┃ ┃ ┣ ui
 ┃ ┃ ┃ ┣ CartPage.tsx
 ┃ ┃ ┃ ┗ index.ts
 ┃ ┃ ┗ index.ts
 ┣ shared
 ┃ ┣ model
 ┃ ┃ ┣ index.ts
 ┃ ┃ ┗ useSelect.ts
 ┃ ┗ ui
 ┃ ┃ ┣ Select.tsx
 ┃ ┃ ┗ index.ts
 ┣ widgets
 ┃ ┣ cart
 ┃ ┃ ┣ ui
 ┃ ┃ ┃ ┣ CartManagement.tsx
 ┃ ┃ ┃ ┗ index.ts
 ┃ ┃ ┗ index.ts
 ┃ ┗ layout
 ┃ ┃ ┣ ui
 ┃ ┃ ┃ ┣ RootLayout.tsx
 ┃ ┃ ┃ ┗ index.ts
 ┃ ┃ ┗ index.ts
 ┗ main.advanced.ts
```

> widget, features, entities 을 구분짓는 것이 가장 큰 어려움이였습니다.
> entities 에는 변하지 않는 데이터들을 위주로 포함시키려고 했습니다.
> features 에는 변하는 상태값에 대한 데이터들과 그 기능들을 위주로 포함시켰습니다.
> widgets 에는 features 의 각 기능 & ui 를 조합하여 만들 수 있는 ui  혹은 layout 을 위주로 포함시켰습니다.

